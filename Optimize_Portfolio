# -*- coding: utf-8 -*-
"""
Created on Mon Mar  1 01:32:44 2021

@author: Yunus Emre Midilli
"""

import pandas as pd
import random
import numpy as np
from deap import base
from deap import creator
from deap import tools
import enum
from datetime import datetime




gc_s_FILE_PATH =r'C:\Users\yunus\Documents\My Project\data\EXPECTED PRICES.csv'


# Assumtions:
    # There is only one base currency TRY
    # There can be multiple exchange rate USD/TRY, EUR/TRY, GBP/TRY etc.
    # There is no transaction cost
    
# Objective Function:
    # Maximize total return


class PortfolioManagement():
        
    # Description: Constructor of class
    # Parameters:
        # dfExpectedPrices: Columns are forward time window, rows are number of financial products
        # dfFinancialProducts: 
        # dfForwardTimeSteps: 
        # decInitialBalance: Initial balance
    # Returs: -
    def __init__(self, dfExpectedPrices,dfFinancialProducts, dfForwardTimeSteps, decInitialBalance):
        self.dfExpectedPrices= dfExpectedPrices
        self.dfForwardTimeSteps = dfForwardTimeSteps
        self.dfFinancialProducts = dfFinancialProducts
        self.decInitialBalance = decInitialBalance
        self.dfIndices = self.dfGetIndices()
        self.aPriceDiffs = self.aGetPriceDiffs()

        
    
    def dfGetIndices(self):
        aI = []
        aJ = []
        aK = []
                      
        for iIndex, iRow in self.dfFinancialProducts.iterrows():
            for jIndex, jRow in self.dfForwardTimeSteps.iterrows():
                jTimeStep =jRow["TimeStep"]
                for kIndex, kRow in self.dfForwardTimeSteps.iterrows():
                    kTimeStep = kRow["TimeStep"]
                    if jTimeStep <= kTimeStep:
                        aI.append(iIndex)
                        aJ.append(jIndex)
                        aK.append(kIndex)

        dicIndices = {
                    "i":aI,
                    "j":aJ,
                    "k":aK,
                    }        
        
        dfIndices = pd.DataFrame(data=dicIndices)    
        
        return dfIndices        


    def aGetPriceDiffs(self):
        
        aPriceDiffs = []
        for iIndex, aRow in self.dfIndices.iterrows():
            i = aRow["i"]
            j = aRow["j"]
            k = aRow["k"]
            

            decPriceDiff = self.dfExpectedPrices.iloc[i][k] - self.dfExpectedPrices.iloc[i][j]
            aPriceDiffs.append(decPriceDiff)

        return aPriceDiffs
       
        
       
    def dfGetDecisionVariables(self, sVariableLetter = "x",):
        aTypes = []
        aLabels = []
        aLowerBounds = []
        aUpperBounds = []
        

        if sVariableLetter == "x":
            iType = variable_types.decimal
        else:
            iType = variable_types.integer   
            
        for iIndex, aRow in self.dfIndices.iterrows():
            i = aRow["i"]
            j = aRow["j"]
            k = aRow["k"]
            
            sLabel = str(sVariableLetter) + "_" + str(i) + "_" + str(j) + "_" + str(k)
            
            if sVariableLetter == "x":
                decUpperBound = self.decInitialBalance
                decLowerBound = 0
            else:
                decUpperBound = 1
                decLowerBound = -1
                
                
            aLabels.append(sLabel)
            aTypes.append(iType)
            aLowerBounds.append(decLowerBound)
            aUpperBounds.append(decUpperBound)

                            

        dicDecisionVariables = {
                    "label":aLabels,
                    "variable_type": aTypes,
                    "lower_bound" : aLowerBounds,
                    "upper_bound" : aUpperBounds
                    }

        

        dfDecisonVariables = pd.DataFrame(data=dicDecisionVariables)       
        return dfDecisonVariables
    
    
    def dfGetObjectiveFunctions(self):
        dicObjectiveFunctions =  {
                        "label":["Fitness"]
                        }
    
        dfObjectiveFunctions = pd.DataFrame(data=dicObjectiveFunctions)
        
        return dfObjectiveFunctions



    def aCalculateReturns(self,aAmountsX, aPositionsY):
        aReturns = []
        for i in range(len(aAmountsX)):
            decReturn = aAmountsX[i] * aPositionsY[i]
            decReturn = self.aPriceDiffs[i] * decReturn
            
            aReturns.append(decReturn)
        return aReturns


    def aCalculateBalances(self, aReturns, aAmounts):
        
        aBalances = np.zeros(self.dfForwardTimeSteps.shape[0])
        
        for iIndex, iRow in self.dfForwardTimeSteps.iterrows():
            
            decTotalReturn = 0
            decTotalAmount = 0
            decCapitalAmount = 0 
            for jIndex, jRow in self.dfForwardTimeSteps.iterrows():
                
                for kIndex, kRow in self.dfFinancialProducts.iterrows():
                    
                    dfIndicAmounts = self.dfIndices[(self.dfIndices.i == kIndex) & (self.dfIndices.j == iIndex) & (self.dfIndices.k == jIndex)]
                    dfIndicReturns = self.dfIndices[(self.dfIndices.i == kIndex) & (self.dfIndices.j == jIndex) & (self.dfIndices.k == iIndex)]
                    dfIndicCapitalAmounts = self.dfIndices[(self.dfIndices.i == kIndex) & (self.dfIndices.j == jIndex) & (self.dfIndices.k == iIndex)]
                    
                    
                    if dfIndicReturns.empty == False:
                        iIndiceReturn = dfIndicReturns.index[0]
                        decTotalReturn = decTotalReturn + aReturns[iIndiceReturn]
                    
                    if dfIndicAmounts.empty == False:
                        iIndiceAmount = dfIndicAmounts.index[0]
                        decTotalAmount = decTotalAmount + aAmounts[iIndiceAmount]
                        
                    if dfIndicCapitalAmounts.empty == False:
                        iIndiceCapitalAmount = dfIndicCapitalAmounts.index[0]
                        decCapitalAmount = decCapitalAmount + aAmounts[iIndiceCapitalAmount]
                        
                                           
            if iIndex == 0:
                 aBalances[iIndex] =  self.decInitialBalance +  decTotalReturn - decTotalAmount + decCapitalAmount
            else:
                aBalances[iIndex] =  aBalances[iIndex - 1] +  decTotalReturn - decTotalAmount + decCapitalAmount

            
        return aBalances
    

            
    
    def dfEvaluateFitness(self, aIndividualX, aIndividualY):
        
        aAmountsX =  list(aIndividualX)
        aPositionsY = list(aIndividualY)
        
        
        aReturns = self.aCalculateReturns(aAmountsX , aPositionsY)
        
        aBalances = self.aCalculateBalances(aReturns, aAmountsX)
        
        
        for i in range(len(aBalances)):
            decBalance = aBalances[i]
            
            if decBalance < 0 :
                return -1

    
        for i in range(len(aReturns)):
            decReturn = aReturns[i]
            
            if  decReturn < 0:
                return -1
                
                
        decFinalBalance =aBalances[len(aBalances)-1] 

        # aTotalReturn = sum(aReturns)
        
        return decFinalBalance
    
    
    
    def Main(self):
        dfDecisonVariablesX = self.dfGetDecisionVariables("x")
        dfDecisonVariablesY = self.dfGetDecisionVariables("y")
        
        dfObjectiveFunctions =  self.dfGetObjectiveFunctions()
        
        creator.create("FitnessFunction", base.Fitness, weights=(1.0,))        
        
        oToolbox = base.Toolbox()
        oToolbox.register("evaluate", self.dfEvaluateFitness)
        oGeneticAlgorithm = GeneticAlgorithm(creator.FitnessFunction,dfObjectiveFunctions, dfDecisonVariablesX, dfDecisonVariablesY)
        dfOptimumResult = oGeneticAlgorithm.optimize(oToolbox)
        
        return dfOptimumResult


class variable_types(enum.Enum):
    integer = 1
    decimal = 2
    
    
    def convert_to_random(eType, vMin, vMax):
        if eType == variable_types.integer:
            return random.randint(vMin, vMax)
        elif eType == variable_types.decimal:
            return random.uniform(vMin, vMax)



class GeneticAlgorithm():
    
    def __init__(self, FitnessFunction,dfObjectiveFunctions, dfDecisonVariablesX, dfDecisonVariablesY, iMaxNumberOfGenerations = 20, iPopulationSize = 50, decSimilarityRatio = 1.0, decCrossoverRate = 0.5,decMutationRate = 0.05, decMutationCrowdingDegree = 0.4):
        self.FitnessFunction = FitnessFunction
        self.dfObjectiveFunctions = dfObjectiveFunctions
        self.dfDecisonVariablesX = dfDecisonVariablesX
        self.dfDecisonVariablesY = dfDecisonVariablesY
        self.iMaxNumberOfGenerations = iMaxNumberOfGenerations
        self.iPopulationSize = iPopulationSize
        self.decSimilarityRatio = decSimilarityRatio
        self.decCrossoverRate = decCrossoverRate
        self.decMutationRate = decMutationRate
        self.decMutationCrowdingDegree = decMutationCrowdingDegree
        
    
    def GenerateIndividual(self, toolbox, dfDecisonVariables, sGroupOfIndividual):

        sGeneOrder = ""
        
        for iIndex, oRow in dfDecisonVariables.iterrows():
            sLabel = oRow["label"]
            eVariableType = oRow["variable_type"]
            decLowerBound = oRow["lower_bound"]
            decUpperBound = oRow["upper_bound"]
            
            toolbox.register(sLabel, variable_types.convert_to_random, eVariableType, decLowerBound, decUpperBound)
            
            
            if sGeneOrder == "":
                sGeneOrder = "toolbox."+sLabel
            else:
                sGeneOrder = sGeneOrder + "," + "toolbox."+sLabel

        toolbox.register(sGroupOfIndividual, tools.initCycle,creator.Individual, eval(sGeneOrder))
    
    
    def aAdjustPopulation(self, aPopulationX,aPopulationY):
        for i in range(len(aPopulationX)):
            aIndividualX = aPopulationX[i]
            aIndividualY = aPopulationY[i]
            
            for j in range(len(aIndividualX)):
                decX = aIndividualX[j]
                iY = aIndividualY[j]
                aIndividualY[j] = int(round(aIndividualY[j]))
                            
                if iY == 0:
                    aPopulationX[i][j] = 0
                else:
                    if decX == 0:
                        aPopulationY[i][j] = 0
                    
        return aPopulationX, aPopulationY
      
        
    def select(self, aPopulationX, aPopulationY):
        aOffspringX = tools.selTournament(individuals = aPopulationX, k = len(aPopulationX), tournsize=self.iPopulationSize)
        aOffspringY = tools.selTournament(individuals = aPopulationY, k = len(aPopulationY), tournsize=self.iPopulationSize)
        
        return aOffspringX, aOffspringY

    
    def crossover(self, aIndividual1X, aIndividual2X, aIndividual1Y, aIndividual2Y):
        if random.random() < self.decCrossoverRate:
            size = len(aIndividual1X)
            cxpoint1 = random.randint(1, size)
            cxpoint2 = random.randint(1, size - 1)
            if cxpoint2 >= cxpoint1:
                cxpoint2 += 1
            else:
                cxpoint1, cxpoint2 = cxpoint2, cxpoint1
        
            aIndividual1X[cxpoint1:cxpoint2], aIndividual2X[cxpoint1:cxpoint2] = aIndividual2X[cxpoint1:cxpoint2].copy(), aIndividual1X[cxpoint1:cxpoint2].copy()
            aIndividual1Y[cxpoint1:cxpoint2], aIndividual2Y[cxpoint1:cxpoint2] = aIndividual2Y[cxpoint1:cxpoint2].copy(), aIndividual1Y[cxpoint1:cxpoint2].copy()
                            
            del aIndividual1X.fitness.values
            del aIndividual2X.fitness.values
            del aIndividual1Y.fitness.values
            del aIndividual2Y.fitness.values
                

    def mutate(self, aIndividual, dfDecisonVariables):            
        tools.mutPolynomialBounded(aIndividual,self.decMutationCrowdingDegree, dfDecisonVariables["lower_bound"].values.tolist(),dfDecisonVariables["upper_bound"].values.tolist(), self.decMutationRate)
    
    
    def optimize(self, toolbox):
        creator.create("Individual", list, fitness = self.FitnessFunction)
        
        self.GenerateIndividual(toolbox, self.dfDecisonVariablesX, "x")
        self.GenerateIndividual(toolbox, self.dfDecisonVariablesY, "y")
        
        toolbox.register("select", self.select)
        toolbox.register("crossover", self.crossover)
        toolbox.register("mutate", self.mutate)
        
        toolbox.register("population_x", tools.initRepeat, list ,toolbox.x)
        toolbox.register("population_y", tools.initRepeat, list ,toolbox.y)
        
        aPopulationX = toolbox.population_x(self.iPopulationSize)
        aPopulationY = toolbox.population_y(self.iPopulationSize)
        
        aPopulationX, aPopulationY = self.aAdjustPopulation(aPopulationX, aPopulationY)
        
        
        dfLabelsX =  self.dfDecisonVariablesX["label"] 
        dfLabelsY =  self.dfDecisonVariablesY["label"] 
        dfBothDecisionVariableLabels = dfLabelsX.append(dfLabelsY)
                
        oOutputFile = Result_Logs.open_output_file(dfBothDecisionVariableLabels,self.dfObjectiveFunctions["label"])
        
        
        aFitnesses = list(map(toolbox.evaluate, aPopulationX, aPopulationY))
        
        for ind, fit in zip(aPopulationX, aFitnesses):
            ind.fitness.values = (fit,)
            
            
        for ind, fit in zip(aPopulationY, aFitnesses):
            ind.fitness.values = (fit,)

           
        iRunId = 1
        for i in range(self.iMaxNumberOfGenerations):
            print("Generation #: " + str(i))
           
            aOffspringX, aOffspringY = toolbox.select(aPopulationX, aPopulationY)

            aOffspringX = list(map(toolbox.clone, aOffspringX)) 
            aOffspringY = list(map(toolbox.clone, aOffspringY))
            
            for aChild1X, aChild2X, aChild1Y,aChild2Y in zip(aOffspringX[::2], aOffspringX[1::2], aOffspringY[::2], aOffspringY[1::2]):            
                toolbox.crossover(aChild1X, aChild2X, aChild1Y, aChild2Y)
                
            for aMutantX in aOffspringX:
                toolbox.mutate(aMutantX,self.dfDecisonVariablesX)
    
            for aMutantY in aOffspringY:
                toolbox.mutate(aMutantY, self.dfDecisonVariablesY)
                
            
            aOffspringX, aOffspringY = self.aAdjustPopulation(aOffspringX, aOffspringY)


            aFitnesses = list(map(toolbox.evaluate, aOffspringX, aOffspringY))

            for ind, fit in zip(aOffspringX, aFitnesses):
                ind.fitness.values = (fit,) 

            for ind, fit in zip(aOffspringY, aFitnesses):
                ind.fitness.values = (fit,)
            
 
            aPopulationX[:] = aOffspringX
            aPopulationY[:] = aOffspringY 
            
           
            for iIndex in range(len(aPopulationX)):
                aIndX = aPopulationX[iIndex]
                aIndY = aPopulationY[iIndex]
                aIndFull = aIndX + aIndY
                
                Result_Logs.log_to_output_file(oOutputFile, iRunId, i+1,aIndFull, aIndX.fitness.values)
                iRunId = iRunId + 1
                
            aBestIndX = tools.selBest(aPopulationX, 1)[0]
            aBestIndY = tools.selBest(aPopulationY, 1)[0]
            
            iBestOccurance = aPopulationX.count(aBestIndX)
            
            if iBestOccurance/self.iPopulationSize >= self.decSimilarityRatio:
                break
                           
            
        aBestIndFull = aBestIndX + aBestIndY
        Result_Logs.log_to_output_file(oOutputFile, "OPTIMUM RESULT", "", aBestIndFull, aBestIndX.fitness.values)
                
        return 


class Result_Logs():
    def open_output_file(aDecisionVariableLabels,aFitnessLabels):
        sTimeStamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        sFileName = sTimeStamp + '.txt'
        
        oOutputFile = open(sFileName, "a")

        sHeader = "Run ID"
        sHeader = sHeader + ';' + "Generation ID"
        sHeader = sHeader + ';' + "Time Stamp"
        sHeader = sHeader + ';' + ';'.join(str(x) for x in aDecisionVariableLabels)
        sHeader = sHeader + ';' +';'.join(str(x) for x in aFitnessLabels)
        oOutputFile.write(sHeader)

        return oOutputFile
    
    
    def log_to_output_file(oOutputFile, iRunId, iGenerationId, aDecisionVariables, aFitnessValues):
        sTimeStamp = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")
        sValues = str(iRunId)
        sValues = sValues + ';' + str(iGenerationId)
        sValues = sValues + ';' + str(sTimeStamp)
        sValues = sValues + ';' + ';'.join(str(x) for x in aDecisionVariables)
        sValues = sValues + ';' + ';'.join(str(x) for x in aFitnessValues)
        
        oOutputFile.write('\n' + sValues)


def dfGetInputs():

    decInitialBalance = 150
    
    
    dfExpectedPrices = pd.read_csv(gc_s_FILE_PATH, index_col=0)
    
    dfForwardTimeSteps = pd.DataFrame(dfExpectedPrices.columns,index = None, columns = ['TimeStep'])
    
    dfFinancialProducts = pd.DataFrame(dfExpectedPrices.index)
    
    
    
    return dfExpectedPrices , dfFinancialProducts , dfForwardTimeSteps, decInitialBalance


dfExpectedPrices , dfFinancialProducts , dfForwardTimeSteps, decInitialBalance = dfGetInputs()
oPortfolioManager = PortfolioManagement(dfExpectedPrices, dfFinancialProducts, dfForwardTimeSteps, decInitialBalance)
dfOptimumResult = oPortfolioManager.Main()
