# -*- coding: utf-8 -*-
"""
Created on Mon Mar  1 01:32:44 2021

@author: Yunus Emre Midilli
"""

import pandas as pd
import random
import numpy as np
from deap import base
from deap import creator
from deap import tools
import enum
from datetime import datetime


# Assumtions:
    # There is only one base currency TRY
    # There can be multiple exchange rate USD/TRY, EUR/TRY, GBP/TRY etc.
    # There is no transaction cost
    
# Objective Function:
    # Maximize total return


class PortfolioManagement():
    
    gc_i_BIG_M = 9999999999999999999999
    
    # Description: Constructor of class
    # Parameters:
        # dfExpectedPrices: Columns are forward time window, rows are number of financial products
        # dfFinancialProducts: 
        # dfForwardTimeSteps: 
        # decInitialCapital: Initial capital
    # Returs: -
    def __init__(self, dfExpectedPrices,dfFinancialProducts, dfForwardTimeSteps, decInitialCapital):
        self.dfExpectedPrices= dfExpectedPrices
        self.dfForwardTimeSteps = dfForwardTimeSteps
        self.dfFinancialProducts = dfFinancialProducts
        self.decInitialCapital = decInitialCapital
        
        
    def dfGetDecisionVariables(self):

        aTypes = []
        aLabels = []
        aLowerBounds = []
        aUpperBounds = []
        aLowerStepSizes = []
        aUpperStepSizes = []
        
        for iCounter in range(2):
            if iCounter == 0:
                iType = variable_types.decimal
                sVariableLetter = "x"
            else:
                iType = variable_types.integer   
                sVariableLetter = "y"
                
            for iIndex, iRow in self.dfFinancialProducts.iterrows():

                for jIndex, jRow in self.dfForwardTimeSteps.iterrows():
                    jTimeStep =jRow["TimeStep"]
                    for kIndex, kRow in self.dfForwardTimeSteps.iterrows():
                        kTimeStep = kRow["TimeStep"]
                        
                        if jTimeStep <= kTimeStep:
                            sLabel = str(sVariableLetter) + "_" + str(iIndex) + "_" + str(jIndex) + "_" + str(kIndex)
                            
                            if iCounter == 0:
                                decUpperBound = self.decInitialCapital
                                decUpperStepSize = self.decInitialCapital * 0.001
                                decLowerBound = 0
                                decLowerStepSize = 0
                            else:
                                decUpperBound = 1
                                decUpperStepSize = 1
                                decLowerBound = -1
                                decLowerStepSize = 0
                                
                            aLabels.append(sLabel)
                            aTypes.append(iType)
                            aLowerBounds.append(decLowerBound)
                            aUpperBounds.append(decUpperBound)
                            aLowerStepSizes.append(decLowerStepSize)
                            aUpperStepSizes.append(decUpperStepSize)
                            
        dicDecisionVariables = {
                    "label":aLabels,
                    "variable_type": aTypes,
                    "lower_bound" : aLowerBounds,
                    "upper_bound" : aUpperBounds,
                    "step_size_lower" : aLowerStepSizes,
                    "step_size_upper" : aUpperStepSizes
                    }


        dfDecisonVariables = pd.DataFrame(data=dicDecisionVariables)       
        return dfDecisonVariables
    
    
    def dfGetObjectiveFunctions(self):
        dicObjectiveFunctions =  {
                        "label":["Fitness"]
                        }
    
        dfObjectiveFunctions = pd.DataFrame(data=dicObjectiveFunctions)
        
        return dfObjectiveFunctions
    
    
    def EnsureConstraints(aPopulationX, aPopulationY):
        
        return aPopulationX, aPopulationY

    
    def bIsPositionAmountConstraintSatisfied(self, aAmountsX, aPositionsY):
        aDiff = aAmountsX - self.gc_i_BIG_M * abs(aPositionsY)
        
        for decDiff in aDiff:
            if decDiff > 0:
                return False
        
        return True
        
    
    def dfEvaluateFitness(self, aIndividualX, aIndividualY):
        
        aAmountsX =  aIndividualX
        aPositionsY = aIndividualY
        
        # bPositionAmountConstraintSatisfied = self.bIsPositionAmountConstraintSatisfied(aAmountsX, aPositionsY)
        
        # # print(bPositionAmountConstraintSatisfied)
        
        # if bPositionAmountConstraintSatisfied == False:
        #     return self.gc_i_BIG_M * -1
        # else:
        #     return self.gc_i_BIG_M
            
        return 1
    
    
    def Main(self):
        dfDecisonVariables = self.dfGetDecisionVariables()
        dfObjectiveFunctions =  self.dfGetObjectiveFunctions()
        
        creator.create("FitnessFunction", base.Fitness, weights=(1.0,))        
        
        oToolbox = base.Toolbox()
        oToolbox.register("evaluate", self.dfEvaluateFitness)
        oGeneticAlgorithm = GeneticAlgorithm(creator.FitnessFunction,dfObjectiveFunctions, dfDecisonVariables)
        dfOptimumResult = oGeneticAlgorithm.optimize(oToolbox)
        
        return dfOptimumResult


class variable_types(enum.Enum):
    integer = 1
    decimal = 2
    
    
    def convert_to_random(eType, vMin, vMax):
        if eType == variable_types.integer:
            return random.randint(vMin, vMax)
        elif eType == variable_types.decimal:
            return random.uniform(vMin, vMax)


class GeneticAlgorithm():
    
    def __init__(self, FitnessFunction,dfObjectiveFunctions, dfDecisonVariables, iMaxNumberOfGenerations = 50, iPopulationSize = 20, decSimilarityRatio = 0.75, decCrossoverRate = 0.5,decMutationRate = 0.05, decMutationCrowdingDegree = 0.4):
        self.FitnessFunction = FitnessFunction
        self.dfObjectiveFunctions = dfObjectiveFunctions
        self.dfDecisonVariables = dfDecisonVariables
        self.iMaxNumberOfGenerations = iMaxNumberOfGenerations
        self.iPopulationSize = iPopulationSize
        self.decSimilarityRatio = decSimilarityRatio
        self.decCrossoverRate = decCrossoverRate
        self.decMutationRate = decMutationRate
        self.decMutationCrowdingDegree = decMutationCrowdingDegree
        
    
    def GenerateIndividual(self, toolbox, sGroupOfIndividual = "x"):

        sGeneOrder = ""
        
        for iIndex, oRow in self.dfDecisonVariables.iterrows():
            sLabel = oRow["label"]
            eVariableType = oRow["variable_type"]
            decLowerBound = oRow["lower_bound"]
            decUpperBound = oRow["upper_bound"]
            toolbox.register(sLabel, variable_types.convert_to_random, eVariableType, decLowerBound, decUpperBound)
            
            sGroup = sLabel[0:1]
            
            if sGroup == sGroupOfIndividual:
                if sGeneOrder == "":
                    sGeneOrder = "toolbox."+sLabel
                else:
                    sGeneOrder = sGeneOrder + "," + "toolbox."+sLabel
            
        toolbox.register(sGroupOfIndividual, tools.initCycle,creator.Individual, eval(sGeneOrder))
    
    
    def aAdjustPopulation(self, aPopulationX,aPopulationY):
        for i in range(len(aPopulationX)):
            decIndividualX = aPopulationX[i]
            iIndividualY = aPopulationY[i]
            
            if iIndividualY == 0:
                aPopulationX[i] = 0
            else:
                if decIndividualX == 0:
                    aPopulationY[i] = 0
                    
        return aPopulationX, aPopulationY
      
        
    def select(self, aPopulationX, aPopulationY):
        aOffspringX = tools.selTournament(individuals = aPopulationX, k = len(aPopulationX), tournsize=self.iPopulationSize)
        aOffspringY = tools.selTournament(individuals = aPopulationY, k = len(aPopulationY), tournsize=self.iPopulationSize)
        
        return aOffspringX, aOffspringY

    
    def crossover(self, aIndividual1X, aIndividual2X, aIndividual1Y, aIndividual2Y):
        if random.random() < self.decCrossoverRate:
            size = len(aIndividual1X)
            cxpoint1 = random.randint(1, size)
            cxpoint2 = random.randint(1, size - 1)
            if cxpoint2 >= cxpoint1:
                cxpoint2 += 1
            else:
                cxpoint1, cxpoint2 = cxpoint2, cxpoint1
        
            aIndividual1X[cxpoint1:cxpoint2], aIndividual2X[cxpoint1:cxpoint2] = aIndividual2X[cxpoint1:cxpoint2].copy(), aIndividual1X[cxpoint1:cxpoint2].copy()
            aIndividual1Y[cxpoint1:cxpoint2], aIndividual2Y[cxpoint1:cxpoint2] = aIndividual2Y[cxpoint1:cxpoint2].copy(), aIndividual1Y[cxpoint1:cxpoint2].copy()
                            
            del aIndividual1X.fitness.values
            del aIndividual2X.fitness.values
            del aIndividual1Y.fitness.values
            del aIndividual2Y.fitness.values
                

    def mutate(self, aIndividual, aUpperBounds, aLowerBounds):            
        tools.mutPolynomialBounded(aIndividual,self.decMutationCrowdingDegree, self.dfDecisonVariables["lower_bound"].values.tolist(),self.dfDecisonVariables["upper_bound"].values.tolist(), self.decMutationRate)
        
        
    def optimize(self, toolbox):
        creator.create("Individual", list, fitness = self.FitnessFunction)
        
        self.GenerateIndividual(toolbox, "x")
        self.GenerateIndividual(toolbox, "y")
        
        toolbox.register("select", self.select)
        toolbox.register("crossover", self.crossover)
        toolbox.register("mutate", self.mutate)
        
        
        toolbox.register("population_x", tools.initRepeat, list ,toolbox.x)
        toolbox.register("population_y", tools.initRepeat, list ,toolbox.y)
        
        aPopulationX = toolbox.population_x(self.iPopulationSize)
        aPopulationY = toolbox.population_y(self.iPopulationSize)
        

        aPopulationX, aPopulationY = self.aAdjustPopulation(aPopulationX, aPopulationY)
        

        oOutputFile = Result_Logs.open_output_file(self.dfDecisonVariables["label"],self.dfObjectiveFunctions["label"] )
        
        aFitnesses = list(map(toolbox.evaluate, aPopulationX, aPopulationY))
        
        
        for ind, fit in zip(aPopulationX, aFitnesses):
            ind.fitness.values = (fit,)
            
        for ind, fit in zip(aPopulationY, aFitnesses):
            ind.fitness.values = (fit,)
           

        iRunId = 1
        for i in range(self.iMaxNumberOfGenerations):
            print("Generation #: " + str(i))

           
            aOffspringX, aOffspringY = toolbox.select(aPopulationX, aPopulationY)

                            
            aOffspringX = list(map(toolbox.clone, aOffspringX)) # Clone the selected individuals
            aOffspringY = list(map(toolbox.clone, aOffspringY)) # Clone the selected individuals
            
            
            for aChild1X, aChild2X, aChild1Y,aChild2Y in zip(aOffspringX[::2], aOffspringX[1::2], aOffspringY[::2], aOffspringY[1::2]):            
                toolbox.crossover(aChild1X, aChild2X, aChild1Y, aChild2Y)
                
            
            # for aMutantX in aOffspringX:
            #     toolbox.mutate(aMutantX,)
    
            # for aMutantY in aOffspringY:
            #     toolbox.mutate(aMutantY)
                
            

            aOffspringX, aOffspringY = self.aAdjustPopulation(aOffspringX, aOffspringY)
            
            aInvalidIndividualsX = [ind for ind in aOffspringX if not ind.fitness.valid] # Evaluate the individuals with an invalid fitness
            aInvalidIndividualsY = [ind for ind in aOffspringY if not ind.fitness.valid] # Evaluate the individuals with an invalid fitness
            
            aFitnesses = map(toolbox.evaluate, aInvalidIndividualsX, aInvalidIndividualsY)
            for ind, fit in zip(aInvalidIndividualsX, aFitnesses):
                ind.fitness.values = (fit,)
                
                
            for ind, fit in zip(aInvalidIndividualsY, aFitnesses):
                ind.fitness.values = (fit,)
                
            
            aPopulationX[:] = aOffspringX
            aPopulationY[:] = aOffspringY 

            aPopulationFull = aPopulationX + aPopulationY
            

            for ind in aPopulationFull:
                Result_Logs.log_to_output_file(oOutputFile, iRunId, i+1,ind, ind.fitness.values)
                iRunId = iRunId + 1
                
            aBestIndX = tools.selBest(aPopulationX, 1)[0]
            aBestIndY = tools.selBest(aPopulationY, 1)[0]
            
            iBestOccurance = aPopulationX.count(aBestIndX)
            
            if iBestOccurance/self.iPopulationSize >= self.decSimilarityRatio:
                break
                           
            
        aBestIndFull = aBestIndX + aBestIndY
        Result_Logs.log_to_output_file(oOutputFile, "OPTIMUM RESULT", "", aBestIndFull, aBestIndX.fitness.values)
                
        return 


class Result_Logs():
    def open_output_file(aDecisionVariableLabels,aFitnessLabels):
        sTimeStamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        sFileName = sTimeStamp + '.txt'
        
        oOutputFile = open(sFileName, "a")

        sHeader = "Run ID"
        sHeader = sHeader + ';' + "Generation ID"
        sHeader = sHeader + ';' + "Time Stamp"
        sHeader = sHeader + ';' + ';'.join(str(x) for x in aDecisionVariableLabels)
        sHeader = sHeader + ';' +';'.join(str(x) for x in aFitnessLabels)
        oOutputFile.write(sHeader)

        return oOutputFile
    
    
    def log_to_output_file(oOutputFile, iRunId, iGenerationId, aDecisionVariables, aFitnessValues):
        sTimeStamp = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")
        sValues = str(iRunId)
        sValues = sValues + ';' + str(iGenerationId)
        sValues = sValues + ';' + str(sTimeStamp)
        sValues = sValues + ';' + ';'.join(str(x) for x in aDecisionVariables)
        sValues = sValues + ';' + ';'.join(str(x) for x in aFitnessValues)
        
        oOutputFile.write('\n' + sValues)


def dfGetInputs():

    decInitialCapital = 150
    
    
    dfFinancialProducts = pd.DataFrame({
                                "FinancialProduct": ["SERIES1", "SERIES2", "SERIES3", "SERIES4"],
                                "RiskFactor":[0.10, 0.50, 0.30, 0.20]
                            })
    
    
    dfForwardTimeSteps= pd.DataFrame({
                                "TimeStep": [1,2,3,4,5]
                            })
    
    
    dfExpectedPrices = pd.DataFrame({})
    
    for iIndex, iRow in dfForwardTimeSteps.iterrows():
        sTimeStep= iRow["TimeStep"]
        dfExpectedPrices.insert(dfExpectedPrices.shape[1], sTimeStep, []) 
    
    
    
    for iIndex, iRow in dfFinancialProducts.iterrows():
        
        aRandomPrices = []
        
        for jIndex, jRow in dfForwardTimeSteps.iterrows():    
            aRandomPrices.append(random.random())
        
        dfExpectedPrices = dfExpectedPrices.append(dict(zip(dfExpectedPrices.columns, aRandomPrices)), ignore_index=True)
    
    dfExpectedPrices = dfExpectedPrices.set_index(dfFinancialProducts["FinancialProduct"])
    
    
    return dfExpectedPrices , dfFinancialProducts , dfForwardTimeSteps, decInitialCapital


dfExpectedPrices , dfFinancialProducts , dfForwardTimeSteps, decInitialCapital = dfGetInputs()
oPortfolioManager = PortfolioManagement(dfExpectedPrices, dfFinancialProducts, dfForwardTimeSteps, decInitialCapital)
dfOptimumResult = oPortfolioManager.Main()
