# -*- coding: utf-8 -*-
"""
Created on Sat Nov 28 23:06:26 2020

@author: yunus
"""

import random

from deap import tools


class genetic_algorithm():
    def __init__(self, population_size = 3, mutation_rate = 0.05, crossoever_rate = 0.5, tournement_size = 3, threshould_error= 0.05, max_number_of_generations = 1,mutation_flip_rate = 0.1):
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossoever_rate = crossoever_rate
        self.tournement_size = tournement_size
        self.threshould_error = threshould_error
        self.max_number_of_generations = max_number_of_generations
        self.mutation_flip_rate = mutation_flip_rate
        

    def optimize_with_genetic_algorithm(self, toolbox):
    
        toolbox.register("mate", tools.cxTwoPoint)
        toolbox.register("mutate", tools.mutFlipBit, indpb=self.mutation_flip_rate)
        toolbox.register("select", tools.selTournament, tournsize=self.tournement_size)
        
        pop = toolbox.population(self.population_size)
        
        print("Start of evolution")
        fitnesses = list(map(toolbox.evaluate, pop))
        for ind, fit in zip(pop, fitnesses):
            ind.fitness.values = (fit,)
            
        print("  Evaluated %i individuals" % len(pop))
        
        # # Extracting all the fitnesses of 
        fits = [ind.fitness.values[0] for ind in pop]
        
        i = 0
        
        while i <= self.max_number_of_generations:
            i = i + 1
            
            print("-- Generation %i --" % i)
            # Select the next generation individuals
            offspring = toolbox.select(pop, len(pop))
            # Clone the selected individuals
            offspring = list(map(toolbox.clone, offspring)) 
            
            # Apply crossover and mutation on the offspring
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                # cross two individuals with probability CXPB
                if random.random() < self.crossoever_rate:
                    toolbox.mate(child1, child2)
    
                    # fitness values of the children
                    # must be recalculated later
                    del child1.fitness.values
                    del child2.fitness.values
            
            for mutant in offspring:
                # mutate an individual with probability MUTPB
                if random.random() < self.mutation_rate:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values
    
            # Evaluate the individuals with an invalid fitness
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = (fit,)
                
            print("  Evaluated %i individuals" % len(invalid_ind))
            # The population is entirely replaced by the offspring
            pop[:] = offspring
            
            # Gather all the fitnesses in one list and print the stats
            fits = [ind.fitness.values[0] for ind in pop]
            
            length = len(pop)
            mean = sum(fits) / length
            sum2 = sum(x*x for x in fits)
            std = abs(sum2 / length - mean**2)**0.5
            
            print("  Min %s" % min(fits))
            print("  Max %s" % max(fits))
            print("  Avg %s" % mean)
            print("  Std %s" % std)
            
            print("-- End of (successful) evolution --")
       
        best_ind = tools.selBest(pop, 1)[0]
        print("Best individual is %s, %s" % (best_ind, best_ind.fitness.values)) 
        
        return best_ind
